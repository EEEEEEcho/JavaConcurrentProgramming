## 并发编程

### 1.进程与线程

#### 1.1 进程与线程

**进程**

- 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的。

- 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。
- 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）

**线程**

- 一个进程之内可以分为一到多个线程。
- 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。
- Java 中，线程作为小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器

**两者对比**

- 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 进程拥有共享的资源，如内存空间等，供其内部的线程共享
  - 进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication）
  - 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP
- 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低

#### 1.2 并行与并发

**并发**

单核 cpu 下，线程实际还是 串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是同时运行的 。总结为一句话就是： 微观串行，宏观并行 ，

![image-20210731100256967](../pic/image-20210731100256967.png)

一般会**将这种线程轮流使用 CPU 的做法称为并发， concurrent**

![image-20210731095923072](../pic/image-20210731095923072.png)

**并行**

多核 cpu下，每个核（core） 都可以调度运行线程，这时候线程可以是并行的。

![image-20210731100405967](../pic/image-20210731100405967.png)

![image-20210731100504734](../pic/image-20210731100504734.png)

引用 Rob Pike 的一段描述：

- 并发（concurrent）是同一时间应对（dealing with）多件事情的能力
- 并行（parallel）是同一时间动手做（doing）多件事情的能力

例子

- 家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流交替做这多件事，这时就是并发
- 家庭主妇雇了个保姆，她们一起这些事，这时既有并发，也有并行（这时会产生竞争，例如锅只有一口，一个人用锅时，另一个人就得等待）

- 雇了3个保姆，一个专做饭、一个专打扫卫生、一个专喂奶，互不干扰，这时是并行

#### 1.3 应用

**1.3.1 代码实例**

**同步调用**

```java
@Slf4j(topic = "c.Sync")
public class Sync {
    public static void main(String[] args) throws InterruptedException {
        log.debug("start sleep");
        TimeUnit.MILLISECONDS.sleep(2000);
        log.debug("end sleep");
        log.debug("do other thing");
    }
}
```

![image-20210731101248670](../pic/image-20210731101248670.png)

**异步调用**

```java
@Slf4j(topic = "c.Async")
public class Async {
    public static void main(String[] args){
        new Thread(() -> {
            log.debug("start sleep");
            try {
                TimeUnit.MILLISECONDS.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.debug("end sleep");
        }).start();
        log.debug("do other thing");
    }
}
```

![image-20210731101343736](../pic/image-20210731101343736.png)

可以发现。执行睡眠操作时的线程名称已经改变了，而且操作的顺序已经发生了改变。

**1.3.2** **应用之异步调用（案例**1)

以调用方角度来讲，如果

- 需要等待结果返回，才能继续运行就是同步
- 不需要等待结果返回，就能继续运行就是异步

**1)** **设计**

多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停...

**2)** **结论**

- 比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程
- tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程
- ui 程序中，开线程进行其他操作，避免阻塞 ui 线程

**1.3.3 应用之提高效率（案例1）**

*计算 1 花费 10 ms*

*计算 2 花费 11 ms*

*计算 3 花费 9 ms*

*汇总需要 1 ms*

- 如果是串行执行，那么总共花费的时间是 10 + 11 + 9 + 1 = 31ms
- 但如果是四核 cpu，各个核心分别使用线程 1 执行计算 1，线程 2 执行计算 2，线程 3 执行计算 3，那么 3 线程是并行的，花费时间只取决于最长的那个线程运行的时间，即 11ms 最后加上汇总时间只会花费 12ms

**注意：需要在多核 cpu 才能提高效率，单核仍然时是轮流执行**

### 2. Java线程

#### 2.1 创建和运行线程

**方法一，直接使用Thread**

```java
// 创建线程对象
Thread t = new Thread() {
 public void run() {
 // 要执行的任务
 }
};
// 启动线程
t.start();
```

例如

```java
@Slf4j(topic = "c.CreateThread1")
public class CreateThread1 {
    public static void main(String[] args) {
        //1.创建线程
        Thread t = new Thread(){
            @Override
            public void run() {
                log.debug("Running");
            }
        };
        //2.指定名称并启动线程
        t.setName("log thread");
        t.start();
        //3.主线程中的打印
        log.debug("Main Running");
    }
}
```

![image-20210731111359220](../pic/image-20210731111359220.png)

**方法二，使用Runnable配合Thread**

把【线程】和【任务】（要执行的代码）分开

- Thread 代表线程
- Runnable 可运行的任务（线程要执行的代码）

```java
Runnable runnable = new Runnable() {
 public void run(){
 // 要执行的任务
 }
};
// 创建线程对象
Thread t = new Thread( runnable );
// 启动线程
t.start();
```

结果

```bash
11:17:21 【runnable】 c.CreateThread2 - Running
```

Java 8 以后可以使用 lambda 精简代码

```java
Runnable runnable = ()->{
    log.debug("Running");
};
Thread thread = new Thread(runnable,"lambda");
thread.start();
```

```java
Thread thread = new Thread(()->{
            log.debug("Running");
        },"lambda");
thread.start();
```

**小结**

- 方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了
- 用 Runnable 更容易与线程池等高级 API 配合
- 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活

**方法三，FutureTask 配合Thread**

FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况

Callable中的run方法可以返回值，而且能抛出异常，但是Runable中的run方法则不行

```java
@Slf4j(topic = "c.CreateThread3")
public class CreateThread3 {
    public static void main(String[] args) {
        Callable<Integer> callable = new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                log.debug("Running");
                Thread.sleep(2000);
                return 10;
            }
        };
        FutureTask<Integer> task = new FutureTask<>(callable);
        Thread thread = new Thread(task,"callable task");
        thread.start();
        try {
            //在主线程中调用FutureTask的get方法，主线程会阻塞 等待线程的执行后返回的结果
            Integer callableReturn = task.get();
            log.debug("{}",callableReturn);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```

```bash
11:33:45 【callable task】 c.CreateThread3 - Running
11:33:47 【main】 c.CreateThread3 - 10
```

#### 2.2 观察多个线程同时运行

```java
@Slf4j(topic = "c.ObserveMultiThread")
public class ObserveMultiThread {
    public static void main(String[] args) {
        new Thread(() -> {
            while (true){
                log.debug("Running t1");
            }
        },"t1").start();

        new Thread(() -> {
            while (true){
                log.debug("Running t2");
            }
        },"t2").start();
    }
}
```

```bash
11:37:10 【t2】 c.ObserveMultiThread - Running t2
11:37:10 【t2】 c.ObserveMultiThread - Running t2
11:37:10 【t1】 c.ObserveMultiThread - Running t1
11:37:10 【t1】 c.ObserveMultiThread - Running t1
11:37:10 【t1】 c.ObserveMultiThread - Running t1
```

至于线程的底层是多个核并行处理这两个线程，还是一个核并发处理这两个线程，是由底层的任务调度器处理的，我们控制不了。

#### **2.3 查看进程的方法**

**windows**

- 任务管理器可以查看进程和线程数，也可以用来杀死进程
- tasklist 查看进程
- taskkill 杀死进程

**linux**

- ps -fe 查看所有进程
- ps -fT -p <PID> 查看某个进程（PID）的所有线程
- kill 杀死进程
- top 按大写 H 切换是否显示线程
- top -H -p <PID> 
- 查看某个进程（PID）的所有线程

**Java**

- jps 命令查看所有 Java 进程
- jstack <PID> 查看某个 Java 进程（PID）的所有线程状态
- jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）

#### 2.4 线程运行原理

Java Virtual Machine Stacks （Java 虚拟机栈）

我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟

机就会为其分配一块栈内存。

- 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

**一个线程的栈帧测试**

```java
public class FrameTest {
    public static void main(String[] args) {
        method1(10);	//断点打在这里
    }
    private static void method1(int x){
        int y = x + 1;
        Object m = method2();
        System.out.println(m);
    }

    private static Object method2(){
        return new Object();
    }
}

```

![image-20210731115346106](../pic/image-20210731115346106.png)

![image-20210731115557695](../pic/image-20210731115557695.png)

![image-20210731115625706](../pic/image-20210731115625706.png)

![image-20210731115654184](../pic/image-20210731115654184.png)

![image-20210731115746628](../pic/image-20210731115746628.png)

![image-20210731121003962](../pic/image-20210731121003962.png)

其余方法调用同理。

![image-20210731121217286](../pic/image-20210731121217286.png)

**两个线程的栈帧测试**

```java
public class FrameTest2 {
    public static void main(String[] args) {
        Thread thread = new Thread(){
            @Override
            public void run() {
                method1(20);	//断点一
            }
        };
        thread.start();

        method1(10);		//断点二
    }
    private static void method1(int x){
        int y = x + 1;
        Object m = method2();
        System.out.println(m);
    }

    private static Object method2(){
        return new Object();
    }
}

```

在打断点时，要调整断点的模式为Thread，右击断点设置即可。

![image-20210731121801251](../pic/image-20210731121801251.png)

开始调试

![image-20210731121923727](../pic/image-20210731121923727.png)

经过执行之后，可以看到每个线程都有自己专有的方法栈和栈帧

![image-20210731160306506](../pic/image-20210731160306506.png)

#### 2.5 线程上下文切换

因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码

- 线程的 cpu 时间片用完
- 垃圾回收
- 有更高优先级的线程需要运行
- 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法

当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念

就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的

- 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等
- Context Switch 频繁发生会影响性能

#### **2.6 常见方法**

![image-20210731161718542](../pic/image-20210731161718542.png)

![image-20210731161751590](../pic/image-20210731161751590.png)

![image-20210731161825525](../pic/image-20210731161825525.png)

**注意，调用Thread.currentThread().isInterrupted()的效果和 当前线程对象.isInterrupted()是一样的，并不是调用的那个静态方法。**

**所以，无论是Thread.currentThread().interrupt()还是 当前线程对象.interrupt()都是将当前线程的打断标记置为true.**

​			**Thread.currentThread().isInterrupted()和 当前线程对象.isInterrupted() 都是返回当前线程的打断标记**



#### **2.7 start和run**

直接调用run方法

```java
@Slf4j(topic = "c.StartAndRun")
public class StartAndRun {
    public static void main(String[] args) {
        Thread t1 = new Thread("t1"){
            @Override
            public void run() {
                log.debug("t1 Running");
            }
        };
        t1.run();
    }
}
```

```bash
16:23:22 【main】 c.StartAndRun - t1 Running
16:23:22 【main】 c.StartAndRun - do other things
```

可以看到，直接调用run方法还是在主线程中调用的run方法，并没有达到异步的效果。所以线程的启动需要使用start方法；

```java
@Slf4j(topic = "c.StartAndRun")
public class StartAndRun {
    public static void main(String[] args) {
        Thread t1 = new Thread("t1"){
            @Override
            public void run() {
                log.debug("t1 Running");
            }
        };
        t1.start();
        log.debug("do other things");
    }
}
```

```bash
16:24:33 【t1】 c.StartAndRun - t1 Running
16:24:33 【main】 c.StartAndRun - do other things
```

start方法只能调用一次。调用多次会出现异常。

#### **2.8 sleep和yield**

**sleep**

- 调用 sleep 会让当前线程从 *Running* 进入 *Timed Waiting* 状态（阻塞）

  ```java
  @Slf4j(topic = "c.SleepAndYield")
  public class SleepAndYield {
      public static void main(String[] args) {
          Thread t1 = new Thread("t1"){
              @Override
              public void run() {
                  try {
                      Thread.sleep(2000);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              }
          };
  
          t1.start();
          log.debug("t1 state {}",t1.getState());
          try{
              Thread.sleep(500);
          }
          catch (Exception e){
              e.printStackTrace();
          }
          log.debug("t1 state {}",t1.getState());
      }
  }
  ```

  ```bash
  16:31:13 【main】 c.SleepAndYield - t1 state RUNNABLE
  16:31:13 【main】 c.SleepAndYield - t1 state TIMED_WAITING
  ```

- 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException

  ```java
  @Slf4j(topic = "c.SleepInterrupted")
  public class SleepInterrupted {
      public static void main(String[] args) throws InterruptedException {
          Thread t1 = new Thread("t1") {
              @Override
              public void run() {
                  log.debug("enter sleep....");
                  try {
                      Thread.sleep(2000);
                  } catch (InterruptedException e) {
                      log.debug("wake up ...");
                      e.printStackTrace();
                  }
              }
          };
          t1.start();
  
          //主线程睡一秒
          Thread.sleep(1000);
          //唤醒t1
          log.debug("interrupt ...");
          t1.interrupt();
      }
  }
  ```

  ```bash
  16:35:53 【t1】 c.SleepInterrupted - enter sleep....
  16:35:54 【main】 c.SleepInterrupted - interrupt ...
  16:35:54 【t1】 c.SleepInterrupted - wake up ...
  java.lang.InterruptedException: sleep interrupted
  	at java.lang.Thread.sleep(Native Method)
  	at com.echo.juc.chapter2.SleepInterrupted$1.run(SleepInterrupted.java:13)
  ```

- 睡眠结束后的线程未必会立刻得到执行

- 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性

  ```java
  public class TimeUnitTest {
      public static void main(String[] args) throws InterruptedException {
          TimeUnit.MILLISECONDS.sleep(1); //睡眠一毫秒
          TimeUnit.SECONDS.sleep(1);  //睡眠一秒
          TimeUnit.HOURS.sleep(1);    //睡眠一小时
      }
  }
  ```

**yield**

- 调用 yield 会让当前线程从 *Running* 进入 *Runnable* 就绪状态，然后调度执行其它线程
- 具体的实现依赖于操作系统的任务调度器

![33492d9a03a4778b7d5f60517b0f08841603442957112](../pic/33492d9a03a4778b7d5f60517b0f08841603442957112.png)

yield是让线程变为就绪状态(可运行状态Runnable)，该线程是仍有机会获得CPU所给的时间片的。但是sleep则是让线程进行了阻塞状态，只有当线程醒过来了，才有机会获得CPU的时间片。

**线程优先级**

- 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它。
- 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用

```java
@Slf4j(topic = "c.PriorityTest")
public class PriorityTest {
    public static void main(String[] args) {
        Runnable task1 = ()->{
            int count = 0;
            for (;;){
                count ++;
                log.debug("t1 count {}",count);
            }
        };
        Runnable task2 = ()->{
            int count = 0;
            for (;;){
                count ++;
                log.debug("t2 count {}",count);
            }
        };

        Thread t1 = new Thread(task1,"t1");
        Thread t2 = new Thread(task2,"t2");
        t1.start();
        t2.start();
    }
}
```

不设置任何优先级时，对于count 的计数如下

```bash
16:49:30 【t1】 c.PriorityTest - t1 count 443762
16:49:30 【t1】 c.PriorityTest - t1 count 443763
16:49:30 【t2】 c.PriorityTest - t2 count 443404
16:49:30 【t2】 c.PriorityTest - t2 count 443405
```

可以发现，两个线程的count值差距并不大。

**使用yield**

```java
@Slf4j(topic = "c.PriorityTest")
public class PriorityTest {
    public static void main(String[] args) {
        Runnable task1 = ()->{
            int count = 0;
            for (;;){
                count ++;
                log.debug("t1 count {}",count);
            }
        };
        Runnable task2 = ()->{
            int count = 0;
            for (;;){
                Thread.yield(); //将cpu使用权优先让给其他线程
                count ++;
                log.debug("t2 count {}",count);
            }
        };

        Thread t1 = new Thread(task1,"t1");
        Thread t2 = new Thread(task2,"t2");
        t1.start();
        t2.start();
    }
}
```

```bash
16:52:45 【t1】 c.PriorityTest - t1 count 213925
16:52:45 【t1】 c.PriorityTest - t1 count 213926
16:52:45 【t1】 c.PriorityTest - t1 count 213927
16:52:45 【t2】 c.PriorityTest - t2 count 53435
16:52:45 【t2】 c.PriorityTest - t2 count 53436
16:52:45 【t2】 c.PriorityTest - t2 count 53437
```

可以发现，明显线程一的计数要大于线程二。因为线程二对于CPU的时间片是能让则让。

**设置优先级**

```java
@Slf4j(topic = "c.PriorityTest")
public class PriorityTest {
    public static void main(String[] args) {
        Runnable task1 = ()->{
            int count = 0;
            for (;;){
                count ++;
                log.debug("t1 count {}",count);
            }
        };
        Runnable task2 = ()->{
            int count = 0;
            for (;;){
                count ++;
                log.debug("t2 count {}",count);
            }
        };

        Thread t1 = new Thread(task1,"t1");
        Thread t2 = new Thread(task2,"t2");
        t1.setPriority(Thread.MAX_PRIORITY);
        t2.setPriority(Thread.MIN_PRIORITY);
        t1.start();
        t2.start();
    }
}
```

```bash
16:54:43 【t2】 c.PriorityTest - t2 count 135060
16:54:43 【t2】 c.PriorityTest - t2 count 135061
16:54:43 【t2】 c.PriorityTest - t2 count 135062
16:54:43 【t1】 c.PriorityTest - t1 count 222830
16:54:43 【t1】 c.PriorityTest - t1 count 222831
16:54:43 【t1】 c.PriorityTest - t1 count 222832
16:54:43 【t1】 c.PriorityTest - t1 count 222833
16:54:43 【t1】 c.PriorityTest - t1 count 222834
16:54:43 【t2】 c.PriorityTest - t2 count 135063
16:54:43 【t2】 c.PriorityTest - t2 count 135064
```

给线程一设置了最高优先级，给线程二设置了最低优先级，从结果可以看出。线程一的计数要比线程二大很多。

#### 2.9 案例：防止CPU占用100%

在一些开发的服务器，或者GUI程序时，可能需要程序一直执行，从而编写while(true)的代码。在没有利用cpu来计算时，为了防止所编写的while (true)空转浪费cpu，可以使用yield或者sleep来让出cpu的使用权给其他程序。(极为有效！)

```java
while (true){
    try {
        Thread.sleep(50);
        //dosomething
    }
    catch (InterruptedException e){
        e.printStackTrace();
    }
}
```

- 可以用 wait 或 条件变量达到类似的效果
- 不同的是，后两种都需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场景
- sleep 适用于无需锁同步的场景

#### 2.10 join方法

考虑下面的代码打印什么？

```java
@Slf4j(topic = "c.JoinDemo")
public class JoinDemo {
    static int r = 0;
    public static void test(){
        log.debug("start");
        Thread t1 = new Thread(() -> {
            log.debug("start");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.debug("end");
            r = 10;
        });
        t1.start();
        log.debug("result:{}",r);
        log.debug("end");
    }

    public static void main(String[] args) {
        test();
    }
}
```

```bash
18:09:18 【main】 c.JoinDemo - start
18:09:18 【Thread-0】 c.JoinDemo - start
18:09:18 【main】 c.JoinDemo - result:0
18:09:18 【main】 c.JoinDemo - end
18:09:19 【Thread-0】 c.JoinDemo - end
```

出现这种情况的原因是：开启的线程要睡一秒才会修改r的值，但是在开启的线程睡的时候，主线程已经执行完了

分析

- 因为主线程和线程 t1 是并行执行的，t1 线程需要 1 秒之后才能算出 r=10
- 而主线程一开始就要打印 r 的结果，所以只能打印出 r=0

解决方法

- 用 sleep 行不行？为什么？
  有时候线程执行的方法是不确定的，主线程并不知道要休眠多久。
- 用 join，加在 t1.start() 之后即可

```java
@Slf4j(topic = "c.JoinDemo")
public class JoinDemo {
    static int r = 0;
    public static void test() throws InterruptedException {
        log.debug("start");
        Thread t1 = new Thread(() -> {
            log.debug("start");
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.debug("end");
            r = 10;
        });
        t1.start();
        t1.join();  //主线程等待t1线程的结束
        log.debug("result:{}",r);
        log.debug("end");
    }

    public static void main(String[] args) throws InterruptedException {
        test();
    }
}
```

```bash
18:23:25 【main】 c.JoinDemo - start
18:23:26 【Thread-0】 c.JoinDemo - start
18:23:27 【Thread-0】 c.JoinDemo - end
18:23:27 【main】 c.JoinDemo - result:10
18:23:27 【main】 c.JoinDemo - end
```

#### 2.11 案例：同步

以调用方角度来讲，如果

- 需要等待结果返回，才能继续运行就是同步
- 不需要等待结果返回，就能继续运行就是异步

![image-20210731182613534](../pic/image-20210731182613534.png)

考虑下面的代码

```java
@Slf4j(topic = "c.MultiJoinDemo")
public class MultiJoinDemo {
    static int r1 = 0;
    static int r2 = 0;

    private static void test2() throws InterruptedException{
        Thread t1 = new Thread(){
            @SneakyThrows
            @Override
            public void run() {
                TimeUnit.SECONDS.sleep(1);
                r1 = 10;
            }
        };
        Thread t2 = new Thread(){
            @SneakyThrows
            @Override
            public void run() {
                TimeUnit.SECONDS.sleep(2);
                r2 = 20;
            }
        };
        long start = System.currentTimeMillis();
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        long end = System.currentTimeMillis();
        log.debug("r1 : {} , r2 : {} , cost : {}",r1,r2,end - start);
    }

    public static void main(String[] args) throws InterruptedException {
        test2();
    }
}
```

```bash
18:35:19 【main】 c.MultiJoinDemo - join begin
18:35:20 【main】 c.MultiJoinDemo - t1 join end
18:35:21 【main】 c.MultiJoinDemo - t2 join end
18:35:21 【main】 c.MultiJoinDemo - r1 : 10 , r2 : 20 , cost : 2003
```

![image-20210731183727024](../pic/image-20210731183727024.png)

**如果颠倒两个join的位置呢？**

```java
@Slf4j(topic = "c.MultiJoinDemo")
public class MultiJoinDemo {
    static int r1 = 0;
    static int r2 = 0;

    private static void test2() throws InterruptedException{
        Thread t1 = new Thread(){
            @SneakyThrows
            @Override
            public void run() {
                TimeUnit.SECONDS.sleep(1);
                r1 = 10;
            }
        };
        Thread t2 = new Thread(){
            @SneakyThrows
            @Override
            public void run() {
                TimeUnit.SECONDS.sleep(2);
                r2 = 20;
            }
        };
        long start = System.currentTimeMillis();
        t1.start();
        t2.start();
        log.debug("join begin");
        t2.join();
        log.debug("t2 join end");
        t1.join();
        log.debug("t1 join end");
        long end = System.currentTimeMillis();
        log.debug("r1 : {} , r2 : {} , cost : {}",r1,r2,end - start);
    }

    public static void main(String[] args) throws InterruptedException {
        test2();
    }
}
```

```bash
18:38:19 【main】 c.MultiJoinDemo - join begin
18:38:21 【main】 c.MultiJoinDemo - t2 join end
18:38:21 【main】 c.MultiJoinDemo - t1 join end
18:38:21 【main】 c.MultiJoinDemo - r1 : 10 , r2 : 20 , cost : 2006
```

仍然是2秒，因为在t2.join()，即等待t2执行的时候，t1也正在执行。所以在调用完t1.join()之后，会立刻完成。

![image-20210731183909536](../pic/image-20210731183909536.png)

**限时join**

```java
@Slf4j(topic = "c.TimeLimitJoinDemo")
public class TimeLimitJoinDemo {
    static int r1 = 0;
    public static void main(String[] args) throws InterruptedException {
        test1();
    }
    private static void test1() throws InterruptedException{
        Thread t1 = new Thread(){
            @SneakyThrows
            @Override
            public void run() {
                TimeUnit.SECONDS.sleep(2);
                r1 = 10;
            }
        };
        long start = System.currentTimeMillis();
        t1.start();
        log.debug("join begin");
        t1.join(1500);  //等待t1 1.5s
        long end = System.currentTimeMillis();
        log.debug("r1 : {}, cost :{}",r1,end - start);
    }
}
```

```bash
18:45:38 【main】 c.TimeLimitJoinDemo - join begin
18:45:40 【main】 c.TimeLimitJoinDemo - r1 : 0, cost :1508
```

因为还差0.5秒，t1才能将r1修改为10，这里只等了1.5秒。但是如果join等待的时间比线程运行时间还要长，那么等待的时间就是线程运行的时间，并不会按照指定的值去等待。

#### 2.12 interrupt方法

**打断sleep,wait,join的线程**

这几个方法都会让线程进入**阻塞**状态

打断 sleep 的线程, 会清空打断状态，以 sleep 为例

```java
@Slf4j(topic = "c.InterruptDemo")
public class InterruptDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread("t1") {
            @Override
            public void run() {
                log.debug("sleep...");
                try {
                    Thread.sleep(5000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        t1.start();
        log.debug("interrupt");
        //等t1睡着
        TimeUnit.SECONDS.sleep(1);
        //打断
        t1.interrupt();
        
        log.debug("interrupt flg {}",t1.isInterrupted());
    }
}

```

```bash
18:57:31 【t1】 c.InterruptDemo - sleep...
18:57:31 【main】 c.InterruptDemo - interrupt
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at com.echo.juc.chapter2.InterruptDemo$1.run(InterruptDemo.java:15)
18:57:32 【main】 c.InterruptDemo - interrupt flg false
```

sleep,wait,join在打断之后，会将打断标记清空，所以打印的是false

**打断正常运行的线程**

打断正常运行的线程, 不会清空打断状态

```java
@Slf4j(topic = "c.InterruptDemo2")
public class InterruptDemo2 {
    public static void main(String[] args) throws InterruptedException{
        Thread t1 = new Thread("t1") {
            @Override
            public void run() {
                while (true) {
                    //在主线程调用t1.interrupted()方法之后，会将打断标记置为真，
                    //在该线程中，判断打断标记是否为真，如果为真，则自己将自己打断
                    boolean interrupted = Thread.currentThread().isInterrupted();
                    if (interrupted){
                        log.debug("被打断了，退出循环");
                        break;
                    }
                }
            }
        };
        t1.start();
        TimeUnit.SECONDS.sleep(1);
        log.debug("interrupt");
        //正常运行的线程，在调用interrupt()方法之后，并不会停止运行。而是将打断标记置为true
        //真正是否要停止运行，是通过判断打断标记，如果为真，就停止运行
        t1.interrupt();
    }
}
```

#### 2.13 两阶段终止模式

在一个线程T1中，如何”优雅“的终止T2？这里的【优雅】是指给T2一个料理后事的机会

**错误思路**

1.使用线程对象的stop()方法停止线程

- stop方法会真正杀死线程，如果这时候线程锁住了共享资源，那么当它被杀死之后就再也没有机会释放锁，其他线程将永远无法获取锁

2.使用System.exit(int)方法停止线程

- 目的是仅停止一个线程，但是这种做法会让整个程序都停止

**流程**

一个后台监控线程，每隔两秒监控一次后台的情况，然后睡眠。

在每次while循环的开始，先检查有没有被打断，如果被打断了，那么处理后事，结束线程。如果没有被打断睡两秒，然后执行监控。

但是，如果是正常执行监控时，被打断，则打断标记会置为true，但是如果是在睡眠状态下被打断，那么打断标记并不会被置为true,所以就需要设置打断标记为true，然后同样的就会出现结束线程，处理后事的正常情况。

![image-20210731191527411](../pic/image-20210731191527411.png)



```java
@Slf4j(topic = "c.TwoParseTermination")
public class TwoParseTerminationDemo {
    public static void main(String[] args) throws InterruptedException {
        TwoParseTermination t = new TwoParseTermination();
        t.start();
        //主线程优雅的去停止该线程.
        TimeUnit.SECONDS.sleep(3);
        t.stop();
    }
}

@Slf4j(topic = "c.TwoParseTermination")
class TwoParseTermination{
    private Thread monitor;

    //启动监控线程
    public void start(){
        monitor = new Thread(){
            @Override
            public void run() {
                while (true){
                    boolean interrupted = Thread.currentThread().isInterrupted();
                    //被打断
                    if (interrupted){
                        log.debug("料理后事");
                        break;
                    }
                    //没被打断,睡眠一秒
                    try {
                        Thread.sleep(1000);
                        log.debug("执行监控记录");
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                        //当睡眠时被打断。手动置打断标记为真
                        //因为睡眠时并不会将打断标记置为true,因此需要手动设置打断标记为true
                        //在这里可以设置成功是因为这里并没有sleep，而是正常的异常捕捉代码块
                        Thread.currentThread().interrupt();
                    }

                }
            }
        };
        monitor.start();
    }

    //停止监控线程
    public void stop(){
        monitor.interrupt();
    }
}
```

```bash
20:29:55 【Thread-0】 c.TwoParseTermination - 执行监控记录
20:29:56 【Thread-0】 c.TwoParseTermination - 执行监控记录
java.lang.InterruptedException: sleep interrupted
	at java.lang.Thread.sleep(Native Method)
	at com.echo.juc.chapter2.TwoParseTermination$1.run(TwoParseTerminationDemo.java:37)
20:29:57 【Thread-0】 c.TwoParseTermination - 料理后事
```

**打断park线程**

```java
@Slf4j(topic = "c.LockParkDemo")
public class LockParkDemo {
    public static void main(String[] args) throws InterruptedException {
        test1();
    }
    private static void test1() throws InterruptedException{
        Thread t1 = new Thread("t1"){
            @Override
            public void run() {
                log.debug("park....");
                //锁住该线程，锁住之后，下面的代码不会执行
                LockSupport.park();
                log.debug("unpark...");
                log.debug("interrupt flg {}",Thread.currentThread().isInterrupted());
                //再锁一次,但是打断标记仍为真，所以不会锁住,只能在上面重置打断标记
                LockSupport.park();
                log.debug("unpark");
            }
        };
        t1.start();
        //主线程睡一秒
        TimeUnit.SECONDS.sleep(1);
        //打断,打断之后，打断标记为真
        t1.interrupt();
    }
}
```

```bash
21:38:18 【t1】 c.LockParkDemo - park....
21:38:19 【t1】 c.LockParkDemo - unpark...
21:38:19 【t1】 c.LockParkDemo - interrupt flg true
21:38:19 【t1】 c.LockParkDemo - unpark
```

#### **2.14 不推荐的方法**

还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁

![image-20210731213929501](../pic/image-20210731213929501.png)

**stop()方法要使用两阶段种植模式来终止**

#### **2.15 主线程与守护线程**

默认情况下，**Java 进程**需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。

```java
@Slf4j(topic = "c.DaemonDemo")
public class DaemonDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread("t1"){
            @Override
            public void run() {
                while (true){
                    if(Thread.currentThread().isInterrupted()){
                        break;
                    }
                }
                log.debug("t1 end");
            }
        };
        //启动前设置为守护线程
        t1.setDaemon(true);
        t1.start();
        TimeUnit.SECONDS.sleep(1);
        log.debug("main end");
    }
}
```

```bash
21:46:10 【main】 c.DaemonDemo - main end
```

主线程已经结束了，虽然守护线程中是死循环，但仍然会被结束

**注意：**

- 垃圾回收器线程就是一种守护线程
- Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求

#### **2.16 线程的五种状态**

五种状态的划分主要是从操作系统的层面进行划分的

![2021-08-05 16-12-06屏幕截图](../pic/2021-08-05%2016-12-06%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)

1. 初始状态，仅仅是在语言层面上创建了线程对象，即`Thead thread = new Thead();`，还未与操作系统线程关联
2. 可运行状态，也称就绪状态，指该线程已经被创建，与操作系统相关联，等待cpu给它分配时间片就可运行
3. 运行状态，指线程获取了CPU时间片，正在运行
   1. 当CPU时间片用完，线程会转换至【可运行状态】，等待 CPU再次分配时间片，会导致我们前面讲到的上下文切换
4. 阻塞状态
   1. 如果调用了阻塞API，如BIO读写文件，那么线程实际上不会用到CPU，不会分配CPU时间片，会导致上下文切换，进入【阻塞状态】
   2. 等待BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】
   3. 与【可运行状态】的区别是，只要操作系统一直不唤醒线程，调度器就一直不会考虑调度它们，CPU就一直不会分配时间片
5. 终止状态，表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态

#### 2.17 线程的六种状态

这是从 Java API 层面来描述的，我们主要研究的就是这种。状态转换详情图：[地址](https://www.jianshu.com/p/ec94ed32895f) 根据 Thread.State 枚举，分为六种状态 Test12.java

![2021-08-05 16-17-45屏幕截图](../pic/2021-08-05%2016-17-45%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)

1. NEW 跟五种状态里的初始状态是一个意思
2. RUNNABLE 是当调用了 `start()` 方法之后的状态，注意，Java API 层面的 `RUNNABLE` 状态涵盖了操作系统层面的【可运行状态（就绪状态）】、【运行状态】和【阻塞状态（操作系统级别的阻塞状态，如文件阻塞读写）】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为是可运行）
3. `BLOCKED` ， `WAITING` ， `TIMED_WAITING` 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节 详述

**演示**

```java
@Slf4j(topic = "c.SixState")
public class SixState {
    public static void main(String[] args) {
        //t1新建出来还没有start
        Thread t1 = new Thread("t1"){
            @Override
            public void run() {
                log.debug("t1 running...");
            }
        };

        //t2一直执行
        Thread t2 = new Thread("t2"){
            @Override
            public void run() {
                while (true){

                }
            }
        };
        t2.start();

        //t3正常执行并结束
        Thread t3 = new Thread("t3"){
            @Override
            public void run() {
                log.debug("t3 running...");
            }
        };
        t3.start();
        
        //t4对SixState.class加锁（可以拿到），然后执行休眠
        Thread t4 = new Thread("t4"){
            @Override
            public void run() {
                synchronized (SixState.class){
                    try {
                        TimeUnit.SECONDS.sleep(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        t4.start();
        
        //t5 等待t2执行完毕，因为t2是死循环，所以一直不会执行完毕
        Thread t5 = new Thread("t5"){
            @Override
            public void run() {
                try{
                    t2.join();
                }
                catch (InterruptedException e){
                    e.printStackTrace();
                }
            }
        };
        t5.start();

        //t6等待拿到SixState.class的锁，但是由于t4没有休眠完成，所以不会得到锁
        Thread t6 = new Thread("t6"){
            @Override
            public void run() {
                //这里t6是拿不到锁的，所以会一直等待锁
                synchronized (SixState.class){
                    //blocked
                    try {
                        TimeUnit.SECONDS.sleep(5000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        t6.start();

        log.debug("t1 state {}", t1.getState());
        log.debug("t2 state {}", t2.getState());
        log.debug("t3 state {}", t3.getState());
        log.debug("t4 state {}", t4.getState());
        log.debug("t5 state {}", t5.getState());
        log.debug("t6 state {}", t6.getState());
    }
}

```

```bash
16:33:26 【t3】 c.SixState - t3 running...
16:33:26 【main】 c.SixState - t1 state NEW
16:33:26 【main】 c.SixState - t2 state RUNNABLE
16:33:26 【main】 c.SixState - t3 state TERMINATED
16:33:26 【main】 c.SixState - t4 state TIMED_WAITING
16:33:26 【main】 c.SixState - t5 state WAITING
16:33:26 【main】 c.SixState - t6 state BLOCKED
```

#### 2.18 案例：统筹规划

t1执行洗水壶和做开水的动作，其中洗水壶1分钟，做开水15分钟。

t2执行洗茶杯，洗茶壶,拿茶叶的动作，其中洗茶杯1分钟，洗茶壶2分钟，拿茶叶1分钟。然后等待t1执行完成后，t2执行泡茶动作

```java
@Slf4j(topic = "c.MakeTea")
public class MakeTea {
    public static void main(String[] args) {
        //t1.洗水壶，烧开水
        Thread t1 = new Thread("t1"){
            @Override
            public void run() {
                log.debug("洗水壶 1分钟");
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("做开水 15分钟");
                try {
                    TimeUnit.SECONDS.sleep(15);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        };
        //t2.洗茶杯，洗茶壶，拿茶叶
        Thread t2 = new Thread("t2"){
            @Override
            public void run() {
                log.debug("洗茶杯 1分钟");
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("洗茶壶 2分钟");
                try {
                    TimeUnit.SECONDS.sleep(2);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("拿茶叶 1分钟");
                try {
                    TimeUnit.SECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                //t2等待t1执行完成后，泡茶
                try {
                    t1.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("泡茶");
            }
        };

        t1.start();
        t2.start();
    }
}

```

后续有更好的解法

#### 2.19 小结

1）线程的创建
2）线程重要的 API，如 start、run、sleep、yield、join、interrupt 等
3）线程的状态
4）原理方面，线程的运行流程，栈、栈帧、上下文切换、程序计数器等知识。
5）Thread 两种创建线程的源码
6）使用 interrupt 来编写两阶段终止

### 3.共享模型之管程

#### 3.1 小故事 

#### 3.2 线程出现问题的原因

线程出现问题的根本原因是因为线程上下文切换，导致线程里的指令没有执行完就切换执行其它线程了

```java
@Slf4j(topic = "c.CurrentError")
public class CurrentError {
    static int count = 0;

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()->{
            for (int i = 0; i < 5000; i++) {
                count ++;
            }
        },"t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                count--;
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug("count :{}",count);
    }
}
```

```bash
17:18:24 【main】 c.CurrentError - count :-755
```

java中对于静态变量执行的自增或者自减都不是原子操作，从字节码部分可以看

```bash
count++; // 操作字节码如下：

getstatic i // 获取静态变量i的值
iconst_1 // 准备常量1
iadd // 自增
putstatic i // 将修改后的值存入静态变量i

count--; // 操作字节码如下：

getstatic i // 获取静态变量i的值
iconst_1 // 准备常量1
isub // 自减
putstatic i // 将修改后的值存入静态变量i
```

Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：

![2021-08-05 17-21-44屏幕截图](../pic/2021-08-05%2017-21-44%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)

如果代码是正常按顺序运行的，那么count的值不会计算错

![20200307162207-752990](../pic/20200307162207-752990.png)

出现负数的情况：

![20200307162301-374560](../pic/20200307162301-374560.png)

出现正数的情况：

![20200307162337-43718](../pic/20200307162337-43718.png)

#### 3.3 临界区 Critical Section

- 一个程序运行多线程本身是没有问题的

- 问题出现在多个线程共享资源的时候
  - 多个线程同时对共享资源进行读操作本身也没有问题
  - 多个线程对共享资源进行读写操作时，发生指令交错，就会出现问题

临界区的概念：一段代码内如果存在对共享资源的多线程读写操作，那么称这段代码为临界区

```java
static int counter = 0;
static void increment(){
    //临界区
    counter ++;
}
static void decrement(){
    //临界区
    counter --;
}
```

#### 3.4 竞态条件

多个线程在临界区执行，那么由于代码指令的执行不确定而导致的结果问题，称为竞态条件

#### 3.5 synchronized解决竞态条件

为了避免临界区中的竞态条件发生，由多种手段可以达到

- 阻塞式解决方案：synchronized ，Lock
- 非阻塞式解决方案：原子变量

现在讨论使用synchronized来进行解决，即俗称的对象锁，它采用互斥的方式让同一时刻至多只有一个线程持有对象锁，其他线程如果想获取这个锁就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换

*注意 虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的： 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区的代码 同步是由于线程执行的先后，顺序不同但是需要一个线程等待其它线程运行到某个点。*

**语法**

```java
synchronized(对象){	//线程一获得锁，那么线程二的状态是block，注意是block，因为sychronized是互斥的。
    临界区
}
```

```java
@Slf4j(topic = "c.SychronizedResolve")
public class SychronizedResolve {
    static int count = 0;
    static Object lock = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()->{
            for (int i = 0; i < 5000; i++) {
                synchronized (lock){   //拿到锁对象，锁住代码
                    count ++;
                }
            }
        },"t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                synchronized (lock){
                    count--;
                }
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug("count :{}",count);
    }
}
```

#### 3.6 synchronized理解

可以做这样的类比:

- synchronized(对象)中的对象，可以想象为一个房间，有唯一入口（门），房间只能一次进入一人进行计算，线程t1,t2可以想象成两个人
- 当线程t1执行到synchronized(room)时，就好比t1进入了这个房间，并锁住了门，拿走了钥匙，在门内执行了count++代码。
- 这时如果t2也运行到了synchronized(room)时，它发现门被锁住了，只能在门外等候，发生了上下文切换，阻塞住了。
- 这时，即使t1的cpu时间片不幸用完，被踢出了门外（不要错误的理解为锁住了对象就能一直执行下去），这时门还是锁住的,t1仍拿着钥匙，t2线程还在阻塞状态进不去，因为t2没有钥匙，只有下次轮到t1自己再次获得时间片时才能开门进入。
- 当t1执行完synchronized{}块内的代码，这时候才会从room房间里出来，并解开门上的锁，唤醒t2线程，把钥匙给它，t2这时才可以进入room房间，锁住门，拿上钥匙，执行代码。

如图

![image-20210809214714772](../pic/image-20210809214714772.png)

synchronized 实际是用**对象锁**保证了**临界区内代码的原子性**，临界区内的代码对外是不可分割的，不会被线程切

换所打断。

**思考**

- 如果把 synchronized(obj) 放在 for 循环的外面，如何理解？-- 原子性

  ```java
  Thread t1 = new Thread(()->{
              synchronized (lock){ //拿到锁对象，锁住代码
                  for (int i = 0; i < 5000; i++) {
                      count ++;
                  }
              }
   },"t1");
  ```

  这样会将整个for循环都锁住，等到整个for循环执行完成后才释放锁。

- 如果 t1 synchronized(obj1) 而 t2 synchronized(obj2) 会怎样运作？-- 锁对象

  ```java
  Thread t1 = new Thread(()->{
      for (int i = 0; i < 5000; i++) {
          synchronized (lock1){   //拿到锁对象，锁住代码
              count ++;
          }
      }
  },"t1");
  Thread t2 = new Thread(() -> {
      for (int i = 0; i < 5000; i++) {
          synchronized (lock2){
              count--;
          }
      }
  }, "t2");
  ```

  这样锁的是两个不同的对象，第一个会给第一个加锁，第二个会给第二个加锁，不能实现互斥

- 如果 t1 synchronized(obj) 而 t2 没有加会怎么样？如何理解？-- 锁对象

  ```java
  Thread t1 = new Thread(()->{
      for (int i = 0; i < 5000; i++) {
          synchronized (lock){   //拿到锁对象，锁住代码
              count ++;
          }
      }
  },"t1");
  Thread t2 = new Thread(() -> {
      for (int i = 0; i < 5000; i++) {
          count--;
      }
  }, "t2");
  ```

  看上面的时序图，虽然t1进行了加锁，但是当时间片分配到t2时，t2并不需要获取锁，也就不会阻塞，从而导致t2在获取到时间片时可以随意操作count的值

**面向对象的改进**

```java
/**
 * 以面向对象的方式改进
 */
@Slf4j(topic = "c.SychronizedResolveOOP")
public class SychronizedResolveOOP {

//    static Object lock = new Object();

    public static void main(String[] args) throws InterruptedException {
        Room room = new Room();
        Thread t1 = new Thread(()->{
            for (int i = 0; i < 5000; i++) {
                room.increment();
            }
        },"t1");
        Thread t2 = new Thread(() -> {
            for (int i = 0; i < 5000; i++) {
                room.decrement();
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug("count :{}",room.getCount());
    }
}
class Room{
    private int count = 0;
    public void increment(){
        //用当前对象自己作为锁对象，保护原子操作
        synchronized (this){
            this.count ++;
        }
    }
    public void decrement(){
        synchronized (this){
            this.count -- ;
        }
    }
    public int getCount(){
        //为了保证获取时得到的是一个完整的结果，
        //而不是指令执行一半之后的结果，也需要加锁
        synchronized (this){
            return this.count;
        }
    }
}
```

```bash
22:03:29 【main】 c.SychronizedResolveOOP - count :0
```

#### 3.7 方法上的synchronized

```java
//非static方法
class Test{
    public synchronized void test() {

    }
}
//等价于
class Test{
    public void test() {
        synchronized(this) {

        }
    }
}
```

```java
//static方法
class Test{
    public synchronized static void test() {
        
    }
}
//等价于
class Test{
    public static void test() {
        synchronized(Test.class) {

        }
    }
}
```

**synchronized只能锁对象**

**不加synchronized**的方法是无法保证方法中的代码的原子性的



**“线程八锁”**

其实就是考察 synchronized 锁住的是哪个对象

情况一

```java
@Slf4j(topic = "c.Number")
class Number{
    public synchronized void a(){
        log.debug("1");
    }
    public synchronized void b(){
        log.debug("2");
    }
}


@Slf4j(topic = "c.ThreadEightLockOne")
public class ThreadEightLockOne {
    public static void main(String[] args) {
        Number number = new Number();
        new Thread(() -> { number.a(); }).start();
        new Thread(() -> { number.b(); }).start();
    }
}
```

```bash
22:15:01 【Thread-0】 c.Number - 1
22:15:01 【Thread-1】 c.Number - 2
```

结果也有可能是先2后1

两个线程锁的都是同一个对象，都是number对象，因为synchronized加在成员方法上相当于锁的是this.



情况二

```java
@Slf4j(topic = "c.Number")
class Number2{
    public synchronized void a() throws InterruptedException {
        TimeUnit.SECONDS.sleep(1);
        log.debug("1");
    }
    public synchronized void b(){
        log.debug("2");
    }
}


@Slf4j(topic = "c.ThreadEightLockTwo")
public class ThreadEightLockTwo {
    public static void main(String[] args) {
        Number2 number = new Number2();
        new Thread(() -> {
            try {
                number.a();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }).start();
        new Thread(() -> { number.b(); }).start();
    }
}
```

```bash
22:57:47 【Thread-0】 c.Number - 1
22:57:47 【Thread-1】 c.Number - 2
```

会出现两种结果，1秒后，打印1 2，或者先打印2 ，1秒后打印1
